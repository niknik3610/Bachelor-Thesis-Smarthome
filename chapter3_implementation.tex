\chapter{Implementation} \label{cha:chapter3}

\section{Technology Choices} \label{sec:chap3:technology}
This section will discuss choices that have been made throughout the project regarding technology used and justifications for their usage.

\subsection{Rust} \label{sec:chap3:technology:rust}
There were a few requirements when choosing an appropriate programming language for this project:
\begin{enumerate} 
    \item Performance: There are two aspects to performance within this project. Performance considerations and optimization are vital on IOT devices themselves, due to their limited on-board processing power. On the other hand, while performance on servers is definitely important, it is significantly easier to scale server-performance, by simply adding more servers (horizontal scaling) or by improving the hardware of any individual server (vertical scaling), than it is to improve performance of an IoT device. This is especially true of an IoT device that is already deployed.
    \item Stability: Another important requirement when choosing a language is the stability of code written in the language. This does not necessarily mean that code written in any language is inherently unstable. This requirement is more of a consideration about if a language enables and encourages a programmer to write code that is memory-safe and handles errors correctly. This is important in an IoT environment, as devices are expected to run for long periods. What is the point of a security camera if it's software crashes every couple days, due to an obscure memory out of bounds error? 
    \item Security: While no language is inherently "hack-proof" or secure, there are ways a language can encourage behaviors that can lead to better outcomes in security. A blog-post by the "Microsoft Security Response Centre" states that 70\% of all vulnerabilities assigned a CVE (Common Vulnerabilities and Exposures) each year are due to memory corruption errors \cite{ProactiveApproachToSecureCode}. In the post the languages "C" and "C++" are specifically referred to as being part of this problem. As mentioned in subsection ~\ref{sec:chap2:security}, security is of particular importance in smart home systems, so ensuring a method or language that enables secure code is chosen is of particular importance. 
    \item Ease of Use and Comfort: While not particularly important in the final product, having a language that is easy to develop in can make the developer experience easier and can lead to faster iteration on ideas, perhaps leading to a better final result. That being said, developer familiarity with a language can more than make up this difference. A seasoned C++ developer will be able to iterate faster and produce a better product in C++, than if they are using an "easy" language, that they are not as familiar with.
\end{enumerate}\todo{not sure I like the list style here}
After some deliberation, the language that was chosen for this project was Rust. While C/C++'s performance rivals and often surpasses Rust, the difference is often quite marginal \cite{PerformanceEvalOnMicrocontroller}, due to all three being compiled to machine code. What makes Rust different, is its headline feature, known as the "borrow checker". While the details of the borrow checker are out of scope of this paper, it can ensure that at compile-time, the code is memory safe. While there are ways to circumvent this (using the "unsafe" keyword), this has to be explicitly done. Due to the code being guaranteed memory safe at compile time, outside the aforementioned unsafe blocks, Rust code is known for its ability to run long-term without running into crashes. Additionally, Rust code is a popular choice for embedded devices, due to being able to compile without a standard library (this has to be enabled), giving it flexibility in a project such as this.

I have decided to use Rust for both the Server and Clients. While Rust might be a somewhat obvious choice for IoT clients, it is less so for servers. Due to the "borrow checker", while Rust might be safe, it is often said to be harder to write than traditional languages. This makes it more questionable as the primary language for the server, due to it being a less constrained platform (view performance section above). While servers are theoretically almost infinitely horizontally scalable, in practice this is often not the case, especially in a smart-home's case, as they have to fit in someone's home and generally should be affordable. Therefore, ensuring that the server can run on as many devices as possible, be it a Raspberry-Pi, or a modern desktop, is an important goal to strive for. The "difficulty" aspect of Rust can be largely counteracted by personal familiarity with the language. Additionally, having a stable server is very important, especially since all IoT devices will need to frequently communicate with this server, an aspect which Rust excels at. Rust also has a thriving community of libraries (known as crates), which using the language gives access to. For these reasons I have chosen Rust as the primary programming language of the Server and Client parts of this project.

\subsection{gRPC} \label{sec:chap3:technology:grpc}
gRPC is an RPC implementation released by Google in 2015. It uses Protocol Buffers (protobufs) as an interface definition language (IDL), to define services on servers, that clients can then call, such as any RPC library. The server runs a gRPC server and the client runs the gRPC client \cite{grpcHomepage}. Protobufs are compiled to many different languages, with many different libraries available for these languages, that automate much of the process. In a performance comparison between REST, gRPC, websockets, GraphQL, gRPC came out ahead in many different metrics \cite{reviewOfInternetProtocols}. These include: 
\begin{itemize}
    \item inserting one value into a database
    \item fetching one value from a database 
    \item fetching one hundred elements  
\end{itemize}
in both native and containerized tests. In fact, gRPC was the most performant internet communication protocol in all metrics apart from memory usage.

Due to its performance and cross-language support I have chosen gRPC as the internet communication protocol for this project. The specific library used for this project is known as "Tonic". Tonic is a Rust gRPC crate that includes both a gRPC server and client. It also utilizes "prost" to compile protobuf files into Rust code, without having to interface the protobuf compiler itself. All protobuf files are compiled as a compilation step of the server and client, eliminating the need for external build scripts (this is only partially true, view Sub Section~\ref{sec:chap3:server:protoBufs}).

\subsection{Typescript \& VueJS} \label{sec:chap3:technology:ts}
While a Command Line Interface (CLI) frontend, written in Rust, will be made available, the main focus will be on the Graphical User Interface (GUI). To ensure that it can run on a variety of systems and is relatively easy to create, it will be web based, using Javascript at runtime. However, it will be written in Typescript. Typescript is a superset of Javascript, that compiles to Javascript and leaves no trace of types behind. Typescript provides a robust type-system, including, but not limited to \cite{understandingTypescript}:
\begin{itemize}
    \item Structural type equivalence, instead of Javascript's by-name type equivalence
    \item Types and concepts for object-based programming
    \item Type operators
\end{itemize}
All of these, while not guaranteeing that the program will be type-safe at runtime, help a developer design more robust and long term solutions generally associated with statically typed languages.

In conjunction with Typescript a web-development framework will be used. Web frameworks are libraries for Javascript that allow easier development of websites and web apps, often incorporating HTML (HyperText Markup Language) and CSS (Cascading Style Sheets) code into Javascript code. They also provide reactivity, meaning that if a variable changes in the code, that change can easily be reflected on the site. This can be done in most frameworks by simply using the variable in the HTML code, something that standard HTML does not support (methods of doing this differs between frameworks).

Most of the choice between different web-frameworks comes down to personal preference and familiarity with a framework. That being said there can be performance differences between different frameworks, that could make a difference on some systems. While there is a lack of formal experiments on framework performance, an informal experiment \cite{performanceComparisonJS} showed that while there is a performance difference between different frameworks, it should not be the primary decision maker. When the difference when creating 1000 rows between vanilla JavaScript and VueJS is 32 milliseconds, the disparity will not be noticeable to the end user. For this reason, and personal familiarity with the framework, I have decided to use VueJS as the frontend development framework for this project.

\subsection{Raspberry Pi} \label{sec:chap3:technology:raspi}
\todo{write this}

\section{Server \& Hub} \label{sec:chap3:server}
Due to the server being the largest part of this project, and practically being a requirement for testing the client and frontend functionality, this will be focused on first. This section will describe defining and compiling protobuf files for API endpoints, server startup, how IOT devices are registered, security mechanisms and how concurrency was handled within the server. 

\subsection{Protocol Buffers and Tonic} \label{sec:chap3:server:protoBufs}
Protobufs are defined within ".proto" files. They use a fairly basic syntax, where the user can define a service using the "service" keyword. A service can contain many functions which a client can call, these are defined using the "rpc" keyword. You can also define the arguments this function takes and what it returns. Structs are defined using the "message" keyword, where each field is separated by a semicolon. Fields can have multiple modifiers, including optional, repeated and map. Repeated marks a field as possibly being a list, or array structure. Map marks a field as being a map data structure. Finally, messages from other files can be imported, using the import keyword and then giving the file-name. \cite{protobufDocs} For an example of a protobuf file view \textbf{\textit{protos/iot/registrationService.proto}}:

\begin{lstlisting}[language=protobuf3, style=boxed]{iot/registrationService.proto}
syntax = "proto3";
package iot.registration;
import "types.proto";

service RegistrationService {
    rpc Register(
        RegistrationRequest
    ) returns (RegistrationResponse);
};

message RegistrationRequest {
    string public_key = 1;
    string name = 2;
    repeated iot.types.DeviceCapabilityStatus capabilities = 3;
}

message RegistrationResponse {
    string public_key = 1;
    string client_id = 2;
    string certificate = 3;
}
\end{lstlisting}

Here we define a service called "RegistrationService", with a function called Register. This function is called by IOT clients when they first attempt to connect to the server which takes a RegistrationRequest as a parameter and returns a RegistrationResponse. The file also defines two "messages", the aforementioned RegistrationRequest and RegistrationResponse. While most of the fields within them are fairly obvious, RegistrationRequest.capabilities warrants further explanation.
    This field is repeated, meaning it is an array data structure. This array contains the type DeviceCapabilityStatus, which is defined in iot.types. We can see this type is imported at the top of the file, from "types.proto". This is the definition of DeviceCapabilityStatus:

\begin{lstlisting}[language=protobuf3, style=boxed]{iot/types.proto}
message DeviceCapabilityStatus {
    bool available = 1;
    string capability = 2;
}
\end{lstlisting}

In summary, if an IOT device wants to register with this server, they will need to call the Register server stub. The server stub takes one parameter, the RegistrationRequest message. This message requires the client to give it's public key, it's display name and an array of "DeviceCapabilityStatus". The Register function then returns a RegistrationResponse. 

To compile these server stubs to Rust we will be using the aforementioned Rust "Tonic" crate. To do this first we must add the "Tonic" crate to our project, then add "tonic-build" to our build dependencies (view Cargo Documentation). We then create a build.rs file, which is run when the Rust compiler (Cargo) builds the program. You can view this file (\textit{backend/build.rs}) below:

\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{backend/build.rs}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_build::compile_protos(
        "../proto/iot/types.proto"
    )?;
    tonic_build::compile_protos(
        "../proto/iot/registrationService.proto"
    )?;
    tonic_build::compile_protos(
        "../proto/iot/requestUpdateService.proto"
    )?;
    tonic_build::compile_protos(
        "../proto/iot/deviceControlService.proto"
    )?;

    tonic_build::configure()
        .type_attribute(
            ".", 
            "#[derive(serde::Deserialize, serde::Serialize)]"
        )
        .compile(
            &[
                "../proto/frontend/registrationService.proto",
                "../proto/frontend/frontendTypes.proto",
                "../proto/iot/types.proto",
                "../proto/frontend/deviceControlService.proto",
            ],
            &["../proto/frontend", "../proto/iot"],
        )?;
    Ok(())
}
\end{lstlisting}

In line 2-13 we are telling tonic\_build, using prost under the hood (which in turn calls the protobuf compiler), to compile the files required for Device \& Server communication. We do this by calling the \textit{compile\_protos} function. The files in the folder \textit{"proto/iot"} are the ones used by IOT devices. This is quite simple to use, however is technically a build script, making the statement in subsection~\ref{sec:chap3:technology:grpc} partially untrue. Line 15-28 are where frontend protobuf files are compiled. These require the traits (Rust equivalent to interfaces in other languages) "Serialize" and "Deserialize" to be implemented for all structs compiled from the files. We therefore require this special syntax when compiling them. For more information on why they need these traits, view subsection~\ref{sec:chap3:frontend:json}.

Finally, protobuf server-stubs and messages can be imported into Rust using a macro provided by tonic. View below how \textit{"backend/server/registration.rs"} imports the \textit{"protos/iot/registration.proto"} file:

\begin{lstlisting}[language=Rust, style=boxed]{server/registration.rs}
use crate::types::types;
pub mod registration_service {
    tonic::include_proto!("iot.registration");
}
\end{lstlisting}

In order to import the compiled protbuf file, we simply call the "include\_proto" macro (it being a macro is indicated by the \textbf{!}). Note that we need to import the types module first, as this module contains the compiled \textit{"protos/iot/types.proto"} file, which is imported by \textit{"registration.proto"}. Additionally, instead of giving the file path to the protobuf file, we simply give the module name, which is also defined in the protobuf file.

\subsection{Server Start Up} \label{sec:chap3:server:startup}
\todo{maybe add a section on how cli arguments are parsed if i need more words (probably not)}

This subsection details what the server handles at startup, including starting the GRPC server, creating server stubs and creating a JSON web server (again, for an explanation on why this is necessary view subsection~\ref{sec:chap3:frontend:json}).

\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
let grpc_server = Server::builder()
    .add_service(
        registration_service_server
            ::RegistrationServiceServer::new(
                registration_service,
        )
    )
    .add_service(
        request_update_service_server
            ::RequestUpdateServiceServer::new(
                polling_service,
        )
    )
    .add_service(
        frontend_registration_service_server
            ::FrontendRegistrationServiceServer::new(
                frontend_registration_service,
        ),
    )
    .add_service(
        frontend_device_control_service_server
            ::FrontendDeviceControlServiceServer::new(
                device_control_service,
        ),
    )
    .serve_with_shutdown(
        grpc_address,
        tokio::signal::ctrl_c().map(drop)
    );

println!("Started GRPC Server on {}", grpc_address);

let grpc_handle = tokio::spawn(async move { grpc_server.await });
\end{lstlisting}
\subsection{Device Registration} \label{sec:chap3:server:registration}


\subsection{Security} \label{sec:chap3:server:security}

\subsection{Threads \& Concurrency} \label{sec:chap3:server:threads}


\section{Device Library} \label{sec:chap3:devicelib}
\section{Example Device} \label{sec:chap3:deviceexample}
\section{Networking}

\section{Web \& CLI Frontend} \label{sec:chap3:frontend}
\subsection{Using JSON for the Frontend API} \label{sec:chap3:frontend:json}
\section{Open Source} \label{sec:chap3:opensource}

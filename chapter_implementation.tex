\chapter{Implementation} \label{cha:implementation}

\todo{split chapter section into design \& implementation}

\section{Server \& Hub} \label{sec:chapimpl:server}
Due to the server being the largest part of this project, and practically being a requirement for testing the client and frontend functionality, this will be focused on first. This section will describe defining and compiling protobuf files for API endpoints, server startup, how IOT devices are registered, security mechanisms and how concurrency was handled within the server. 

\subsection{Protocol Buffers and Tonic} \label{sec:chapdesign:server:protoBufs}
\todo{I think this section is probably fine, just talk some more about what these protobufs and method stubs will be used for}
Protobufs are defined within ".proto" files. They use a fairly basic syntax, where the user can define a service using the "service" keyword. A service can contain many functions which a client can call, these are defined using the "rpc" keyword. You can also define the arguments this function takes and what it returns. Structs are defined using the "message" keyword, where each field is separated by a semicolon. Fields can have multiple modifiers, including optional, repeated and map. Repeated marks a field as possibly being a list, or array structure. Map marks a field as being a map data structure. Finally, messages from other files can be imported, using the import keyword and then giving the file-name. \cite{protobufDocs} For an example of a protobuf file view \textbf{\textit{protos/iot/registrationService.proto}}:

\begin{lstlisting}[language=protobuf3, style=boxed]{iot/registrationService.proto}
syntax = "proto3";
package iot.registration;
import "types.proto";

service RegistrationService {
    rpc Register(
        RegistrationRequest
    ) returns (RegistrationResponse);
};

message RegistrationRequest {
    string public_key = 1;
    string name = 2;
    repeated iot.types.DeviceCapabilityStatus capabilities = 3;
}

message RegistrationResponse {
    string public_key = 1;
    string client_id = 2;
    string certificate = 3;
}
\end{lstlisting}

Here we define a service called "RegistrationService", with a function called Register. This function is called by IOT clients when they first attempt to connect to the server which takes a RegistrationRequest as a parameter and returns a RegistrationResponse. The file also defines two "messages", the aforementioned RegistrationRequest and RegistrationResponse. While most of the fields within them are fairly obvious, RegistrationRequest.capabilities warrants further explanation.
    This field is repeated, meaning it is an array data structure. This array contains the type DeviceCapabilityStatus, which is defined in iot.types. We can see this type is imported at the top of the file, from "types.proto". This is the definition of DeviceCapabilityStatus:

\begin{lstlisting}[language=protobuf3, style=boxed]{iot/types.proto}
message DeviceCapabilityStatus {
    bool available = 1;
    string capability = 2;
}
\end{lstlisting}

In summary, if an IOT device wants to register with this server, they will need to call the Register server stub. The server stub takes one parameter, the RegistrationRequest message. This message requires the client to give it's public key, it's display name and an array of "DeviceCapabilityStatus". The Register function then returns a RegistrationResponse. For more information on this topic, view subsection~\ref{sec:chapimpl:server:registration}

To compile these server stubs to Rust we will be using the aforementioned Rust "Tonic" crate. To do this first we must add the "Tonic" crate to our project, then add "tonic-build" to our build dependencies (view Cargo Documentation). We then create a build.rs file, which is run when the Rust compiler (Cargo) builds the program. You can view the file \textbf{\textit{backend/build.rs}} below:

\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{backend/build.rs}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_build::compile_protos(
        "../proto/iot/types.proto"
    )?;
    tonic_build::compile_protos(
        "../proto/iot/registrationService.proto"
    )?;
    tonic_build::compile_protos(
        "../proto/iot/requestUpdateService.proto"
    )?;
    tonic_build::compile_protos(
        "../proto/iot/deviceControlService.proto"
    )?;

    tonic_build::configure()
        .type_attribute(
            ".", 
            "#[derive(serde::Deserialize, serde::Serialize)]"
        )
        .compile(
            &[
                "../proto/frontend/registrationService.proto",
                "../proto/frontend/frontendTypes.proto",
                "../proto/iot/types.proto",
                "../proto/frontend/deviceControlService.proto",
            ],
            &["../proto/frontend", "../proto/iot"],
        )?;
    Ok(())
}
\end{lstlisting}

In line 2-13 we are telling tonic\_build, using prost under the hood (which in turn calls the protobuf compiler), to compile the files required for Device \& Server communication. We do this by calling the \textit{compile\_protos} function. The files in the folder \textit{proto/iot} are the ones used by IOT devices. This is quite simple to use, however is technically a build script, making the statement in subsection~\ref{sec:chapdesign:technology:grpc} partially untrue. Line 15-28 are where frontend protobuf files are compiled. These require the traits (Rust equivalent to interfaces in other languages) "Serialize" and "Deserialize" to be implemented for all structs compiled from the files. We therefore require this special syntax when compiling them. For more information on why they need these traits, view subsection~\ref{sec:chapimpl:frontend:json}.

Note that the words crate and library will be used interchangeably throughout this report, due to them being very similar concepts, but library being more familiar to non-rust users.

Finally, protobuf server-stubs and messages can be imported into Rust using a macro provided by tonic. View below how \textbf{\textit{backend/src/server/registration.rs}} imports the \textit{protos/iot/registration.proto} file:

\begin{lstlisting}[language=Rust, style=boxed]{server/registration.rs}
use crate::types::types;
pub mod registration_service {
    tonic::include_proto!("iot.registration");
}
\end{lstlisting}

In order to import the compiled protbuf file, we simply call the "include\_proto" macro (it being a macro is indicated by the \textbf{!}). Note that we need to import the types module first, as this module contains the compiled \textit{protos/iot/types.proto} file, which is imported by \textit{registration.proto}. Additionally, instead of giving the file path to the protobuf file, we simply give the module name, which is also defined in the protobuf file.

\subsection{Server Start Up} \label{sec:chapimpl:server:startup}
This section will describe what is done when the server first starts. It will give a general overview of startup and the details of starting a gRPC and HTTP server in Rust. For more details, view the main function within \textit{\textbf{/backend/src/server/server.rs}}.

Startup of the server is currently quite simple:

\begin{figure}[h]
\caption{Simplified Diagram of Server Startup}
\includegraphics[width=\textwidth]{server_startup}
\end{figure}

\subsubsection{Command Line Arguments}
Command line (CLI) arguments are parsed using a Rust library called "Clap". Currently the only commandline argument that can be passed is running the optional HTTP server, which enables using JSON for the frontend (view subsection~\ref{sec:chapimpl:frontend:json}), however there are plans to include other arguments, such as giving an IP address or Port for the gRPC server to run on as an argument. Currently, the computer's IP address is discovered automatically using a crate called "local-ip-address". 

\subsubsection{Creating gRPC Services}
Next gRPC services are instantiated. GRPC services in Rust take the form of structs that implement the trait (interface) defined as a service within a protbuf file. Take for example, the "RegistrationService" from \textbf{\textit{protos/iot/registrationService.proto}}, defined in subsection~\ref{sec:chapdesign:server:protoBufs}:
\begin{lstlisting}[language=protobuf3, style=boxed, showstringspaces=false]{}
service RegistrationService {
    rpc Register(
        RegistrationRequest
    ) returns (RegistrationResponse);
};
\end{lstlisting}

This is implemented on a struct in Rust like this (code snippet from \textit{\textbf{backend/src/server/registration.rs}}):
\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
use self::registration_service
    ::registration_service_server::RegistrationService;

#[async_trait]
impl RegistrationService for ClientRegistrationHandler {
    async fn register(
        &self,
        request: tonic::Request<
            self::registration_service::RegistrationRequest
        >,
    ) -> RPCFunctionResult<
        self::registration_service::RegistrationResponse
    > {
        //code goes here
    }
}
\end{lstlisting}

Where "RegistrationService" is the trait we are implementing and "ClientRegistrationHandler" is the name of the struct it is being implemented on. If the trait is implemented correctly, this struct is now a service and, after being handed to the gRPC server struct, this function can then be called using an RPC through gRPC. In other words, any gRPC client that is connected to this gRPC server can now call this function, as long as their programming language supports it.

\subsubsection{Starting the gRPC Server}
After implementing all services defined in the protobuf files on appropriate structs, the gRPC server can now be started. This is done in the following code snippet from \textit{\textbf{/backend/src/server/server.rs}}:
\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
use registration_service_server::RegistrationServiceServer;

let registration_service =
    registration::ClientRegistrationHandler::new();
let grpc_server = tonic::transport::Server::builder()
    .add_service(
        RegistrationServiceServer::new(
            registration_service,
        )
    )
    .serve_with_shutdown(
        grpc_address,
        tokio::signal::ctrl_c().map(drop)
    )
    .await;

println!("Started GRPC Server on {}", grpc_address);
\end{lstlisting}
\textit{Note that the above code snippet is abbreviated for readability, it is however still valid Rust code and gives a good representation of what is done in server.rs.} 

The Server struct we are instantiating on line 1 comes from the transport module within the tonic crate. We invoke the builder method on the Server struct, a very common pattern within the Rust ecosystem. In fact, the same pattern is used instantiate a new IoT device in the client library for this project (view section~\ref{sec:chapimpl:devicelib}). After invoking the builder method, which returns a new Server struct, we add structs that implement the aforementioned services to it, using the "add\_service" method. In our case, we want to hand it a "RegistrationServiceServer" struct, provided by the protobuf file. The "new" method on the "RegistrationServiceServer" takes one argument, which is a struct that implements the "RegistrationService" trait, which is the trait we implemented on our ClientRegistrationHandler earlier. We therefore hand it the variable "registration\_service" which is of the type "ClientRegistrationHandler".

The "server\_with\_shutdown" method consumes the Server struct and runs the server, on the address handed to it in the parameter. In this case it is the variable "grpc\_address", which is a string which contains the device's IP address and a port. The second parameter simply tells Rust to drop the gRPC server (shutdown and gracefully free the memory associated with it) when the key combination crtl-c is pressed. This is an easy way to implement this behavior in Rust when working with multiple threads (view subsection~\ref{sec:chapimpl:server:threads}).

Once we have added all services to the Server struct, it must be awaited using the "await" keyword. For more information on how this works view subsection~\ref{sec:chapimpl:server:threads}.  

\subsubsection{Starting the HTTP Server}
Starting the HTTP server works almost the same as the gRPC server, using the same builder pattern. However, this time instead of using the Tonic crate, we are using a crate named "Actix", a self-described "powerful, pragmatic, and extremely fast web framework for Rust" \cite{actixWebsite}. View part of the "run\_json\_frontend" function, found in the file \textbf{\textit{backend/src/server/server.rs}} below:
\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
const JSON_ADDRESS: &str = "localhost:50052";

let result = actix_web::HttpServer::new(move || {
    actix_web::app::App::new()
        .app_data(web::Data::new(json_state.clone()))
        .service(json_registration::json_registration)
})
.bind(JSON_ADDRESS)?
.run()
.await;

println!("Successfully Started JSON API Layer on {JSON_ADDRESS}");
\end{lstlisting}
\textit{Note that the above code snippet is abbreviated for readability, it is however still valid Rust code and gives a good representation of what is done in server.rs.} 

Due to this builder function requiring more Rust specific knowledge to understand, it will be simplified here. It is functionally the same as the one seen from Tonic. First we create a new HTTPServer struct from the actix\_web module. We then hand it our services using the "service" method. What is different here, is that we are actually handing it callback functions, instead of structs with traits implemented. To view an example of these services, view subsection~\ref{sec:chapimpl:server:registration}. From there we bind this server to the constant string JSON\_ADDRESS. This is an IP Address defined at compile time, the definition however is found above the web server. The server is running on localhost, as it is meant for communication with the web frontend. We then call the run method and await the result. In reality the server is being awaited on a different thread than the gRPC server, so the two can run concurrently, this is not shown in the above code snippet. 

For code beyond the above provided abbreviated snippets view the file \textbf{\textit{backend/src/server/server.rs}}, which contains the main function for the server.

\subsection{Device Registration} \label{sec:chapimpl:server:registration} 
This section will give an overview of the server's response to a device registration attempt. For information about how registration is performed on a device, view subsection~\ref{sec:chapimpl:devicelib:registration}

Figure~\ref{fig:server_registration} shows the process of the server receiving a registration request from a client:

\begin{figure}[h]
\caption{Simplified Diagram of Device Registration}
\includegraphics[width=\textwidth]{device_registration}
\label{fig:server_registration}
\end{figure}
When a device wants to connect to the server, it uses the "Register" function from the "RegistrationService" through gRPC. To do so, it must first create a "RegistrationRequest", the contents of which are detailed within the \textit{\textbf{proto/iot/registration.proto}} protobuf file:
\pagebreak
\begin{lstlisting}[language=protobuf3, style=boxed, showstringspaces=false]{}
message RegistrationRequest {
    string public_key = 1;
    string name = 2;
    repeated iot.types.DeviceCapabilityStatus capabilities = 3;
}

//from proto/iot/types.proto
message DeviceCapabilityStatus {
    bool available = 1;
    string capability = 2;
}
\end{lstlisting}
This is the same protobuf code detailed in subsection~\ref{sec:chapdesign:server:protoBufs}. The "RegistrationRequest" contains the device's public key and its display name. The public key will be used for encryption and signing, the name is what the device is called on the frontend-interface. The final field is an array of type "DeviceCapabilityStatus", which is a message (struct) with two fields. A capability in this system represents something the device can do. This takes the form of a string. If a capability is available, that means the server relays that capability to any frontend devices connected to the server. If it is not available, the server still keeps that information, but does not relay it to frontends. 

A simple example of a capability is one for a lamp. A lamp could have two capabilities, "turn on" and "turn off". If the lamp is off, the capability "turn on" is available to the user. If the user decides to invoke that capability, the lamp will turn on, the "turn on" capability will no longer be available and the "turn off" capability will become available. 

This system has much room for extension, with some glaring features that need to be added being:
\begin{itemize}
    \item Optional variables attached, such as a float value. Could be used for turning up a speaker for example.
\todo{still planning to implement this before deadline, add more stuff here}
    \item Access levels, only an admin can see this capability.
\end{itemize}

The device sends this registration request to the server. With the information from the request, the server can then register the device in a HashMap, which maps the device UUID to the Device struct, following the steps described in figure~\ref{fig:server_registration}. The Device struct is defined in \textit{\textbf{/backend/src/server/device.rs}} as:
\todo{fix this code snippet}
\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
use crate::types::types::DeviceCapabilityStatus;
#[derive(Clone)]
pub struct Device {
    pub name: String,
    pub uuid: Uuid,
    pub stringified_uuid: String,
    pub active_capabilities: Vec<DeviceCapabilityStatus>,
    pub inactive_capabilities: Vec<DeviceCapabilityStatus>,
    pub device_public_key: rsa::RsaPublicKey,
}
\end{lstlisting}
The structure of a device is quite self-explanatory, the only thing of note is having the UUID as two fields, one time as the UUID struct and once as a string. This is due to the type conversion being done very often in certain sections of code, it made sense to do this conversion once and reuse it.  
    Note that in the current system, a device needs to re-register every time the server restarts. It doesn't need to re-register on device restart, as long as the certificate and UUID are retained. An easy way for the server to save devices, so they can be remembered after restarting would be to serialize the hash map which maps UUIDs to Device structs and then to load this at startup. However, this would require more advanced logic to decide when to kick inactive devices out of the hash map and could lead to unforeseen bugs. Therefore, it is another possible extension of the project for the future.

\subsection{Device \& Server Communication}
Device and Server communication happens through polling. Every 0.5 seconds the device sends a request through the "RequestUpdateService" to the server. The service is defined in the \textit{\textbf{/protos/iot/requestUpdateService.proto}} file:
\begin{lstlisting}[language=protobuf3, style=boxed, showstringspaces=false]{}
service RequestUpdateService {
    rpc PollForUpdate(PollRequest) returns (PollResponse);
};

message PollRequest {
    string certificate = 1;
    string uuid = 2;
    repeated iot.types.DeviceCapabilityStatus 
        updatedCapabilities = 3;
};

message PollResponse {
    PollingOption hasUpdate = 1;
    repeated Update updates = 2;
};

enum PollingOption {
    UNKNOWN = 0;
    NONE = 1;
    SOME = 2;
    DEVICE_NOT_FOUND = 3;
}

message Update {
    string capability = 1;
    bool hasValue = 2;
    int32 value = 3;
}
\end{lstlisting}
The "RequestUpdateService" has one function, named "PollForUpdate". It accepts a "PollRequest" as a parameter and returns a "PollResponse". When a device requests an update from the server, it must provide it's UUID and certificate, so the server knows what device is requesting and so the server can ensure that the device is who it says it is. Additionally, it provides it's updated list of capabilities. Below is some pseudocode to show how the server creates a response (you can view the real function in file \textit{\textbf{backend/src/server/polling.rs}}): \todo{add signature to this}

\begin{lstlisting}[language=Python, style=boxed, showstringspaces=false]{}
def poll_for_update(self, request):
    device = self.connected_devices.get(request.uuid)
    if device == null:
        return PollResponse(
            has_update: PollingOption::DeviceNotFound,
            updates: [],
        )

    if !request.updatedCapabilities.is_empty():
        active_capabilities, inactive_capabilities = (
            request.updatedCapabilities.partition(
                (capability) => capability.available == True
            )
        )
        device.replace_capabilities(
            active_capabilities,
            inactive_capabilities
        )

        self.frontend_cache_valid = false

    updates = self.updates.get(request.uuid)
    if updates.is_empty():
        return PollResponse(
            has_update: NONE,
            updates: [],
        )

    updates_clone = updates.clone()
    updates.clear()

    return PollResponse(
        has_update: SOME,
        updates: updates_clone
    )
\end{lstlisting}
In summary, when the poll\_for\_update function receives a request, it first checks if the device has updated capabilities. This can happen if something has changed with the device since the last poll or since registration. If the device has updates capabilities, then they are replaced and the frontend cache is invalidated. The frontend cache being invalidated means that some values need to be recalculated next time a frontend requests information about this device, instead of simply using the previous values.

Next the function checks if any events are available for the device in question. Events in this case are generated by the frontend. For example, when the frontend activates capability "turn\_on", an event is created on the server for the corresponding device. When the device then requests updates, this event is sent to the device and the device can respond accordingly. Within the PollResponse struct (view the protobuf definition above), the "hasUpdate" field corresponds to the status of events. If the server responds with NONE, this means that no events are available, if it responds with SOME then the updates field contains updates. While the client could simply check for the length of the updates array, "hasUpdate" also provides some error handling, such as reporting if the device was not found or if some error occurred.

When the client receives the response to their poll, they can then decide what to do with the events they have received, the server does not define any behavior. It simply reports to the client any events that have happened. This choice was made to enable a programmer to better define device behaviour themselves and prevents issues with the server and device being out of sync about what behaviors are available. The downside of this, is that the server cannot guarantee to the frontend that anything has happened when a button is clicked. It also cannot give feedback until the event is processed by the IoT device. Another downside is that it leads to more calculation being done on the IoT device itself.


\subsection{Threads \& Concurrency} \label{sec:chapimpl:server:threads}
\todo{write this}

\section{Device Library \& Example Device} \label{sec:chapimpl:devicelib}
Another goal of this project was to create a library that can be used by other programmers, to easily create an IoT device that can connect to this system. This library was written for use with Rust. It is published within the Rust library ecosystem website, found at \textit{crates.io}. The library entry on \textit{crates.io} can be found be \textbf{\href{https://crates.io/crates/NOSHP-Client}{here}}. 

\subsection{Using the Library}
\todo{some of this code has outdated code fix that}
The main purpose of the library to is to abstract details of how the client \& server connection works away from the programmer. While they can still view the source code due to it being open source, they should not need to know the inner workings of the library to be able to use it. The example below, which can be found within the repository for the example device \textbf{\href{https://github.com/niknik3610/Example-Iot-Device}{here}}, demonstrates usage of the library to create a simple IoT device. The purpose of this device is to toggle an LED, attached to a general purpose input output (GPIO) pin, on and off when the appropriate event is received. This code is made to run on a Raspberry Pi and will therefore not run on non Raspberry Pi Devices. It uses a combination of the NOSHP\_Client library (the library created within this paper) and rrpal, a library commonly used to interact with the Raspberry Pi's GPIO in Rust. View the entire code for this simple IoT device and an in depth explanation of it below: 

\pagebreak
\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
use NOSHP_Client::{
    client::{ClientHandler, Request, State},
    client_config::{ClientConfig, ParsedConfig},
};
use std::error::Error;
use rppal::gpio::{Gpio, OutputPin};

struct ExampleState {
    led_pin: OutputPin,
}
impl State for ExampleState {}
impl Default for ExampleState {
    fn default() -> ExampleState {
        return ExampleState {
            led_pin: Gpio::new()
                .unwrap()
                .get(GPIO_LED_PIN)
                .unwrap()
                .into_output(),
        };
    }
}

const GPIO_LED_PIN: u8 = 2;
const CONFIG_PATH: &str = "./example_config.toml";
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let config = 
        ClientConfig::load_config(CONFIG_PATH).unwrap();

    let client_handler = ClientHandler::new()
        .add_callback("Turn On", Box::new(turn_on_led))
        .add_callback("Turn Off", Box::new(turn_off_led))
        .run(config)
        .await
        .unwrap();

    return Ok(());
}

fn turn_on_led(state: &mut ExampleState, req: Request) {
    state.led_pin.set_high();
    println!("set pin {} to high", GPIO_LED_PIN);
}
fn turn_off_led(state: &mut ExampleState, req: Request) {
    state.led_pin.set_low();
    println!("set pin {} to low", GPIO_LED_PIN);
}
\end{lstlisting}

\subsubsection{State}
On line 8 the state struct of the program is defined. State will later be shared between callback functions. This can be defined by the user to fit their needs. The only requirement is that the user defined state struct must implement two interfaces. The first is called "State" and is imported on line 2 from the NOSHP\_Client library (our library). This State interface is currently empty, it has no required functions, it exists to make future additions to the library easier to integrate. If it is decided that a function is required on the state struct, it can be easily added to the interface and the user will get a compile time error that is easy to understand. The second interface is called Default. It simply defines the default implementation of the struct, in this case constructing a new "ExampleState" (the name of our State struct), with the "led\_pin" field set to the appropriate GPIO pin (defined on line 24), in this case where the pin the LED is connected to. This will then later be used by callback functions (view Callback Functions), to turn on the LED, without having to construct a new GPIO struct every time.

\subsubsection{Configuration}
Next we will have a look at the main function. On line 28 the configuration for the client is loaded from a file. This file is defined in a constant on line 25, under \textit{./example\_config.toml}. The configuration files for the client library are written in Tom's Obvious Minimal Language (TOML), a language often used in Rust projects. Its usage is similar to languages such as JSON or YAML (Yet another markup language). The configuration file looks like this:

\begin{lstlisting}[language=, style=boxed, showstringspaces=false]{}
device_name = "Pi"
server_ip = "http://192.168.0.0:2302"

[capability."Turn Off"]
    available = true

[capability."Turn On"]
    available = true
\end{lstlisting}
This configuration is loaded using the "load\_config" method from our library, imported on line 3. 
\subsubsection{The Client Handler}
On line 31, we finally construct the client handler, by calling the "new" method on the "ClientHandler" struct, imported from our library on line 2. Calling the new method initializes the variables inside the ClientHandler, including calling the default method on our State. This might be confusing to someone who is new to Rust, as we never informed the ClientHandler of the ExampleState struct. In this case Rust uses type inference, to infer what struct we are trying to use as our client's state. It infers this information from the callback functions we pass to it using the "add\_callback" method, as they define one of their parameters to be "ExampleState". If we were to remove these calls to "add\_callback", Rust would throw an error at compilation, stating that we need to specify the type of State. The definition of "ClientHandler" looks like this (from \textit{\textbf{client\_library/src/client.rs}}):
\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
pub type Callback<S: State> = fn(&mut S, Request);
pub struct ClientHandler<S: State> {
    callbacks: FxHashMap<String, Box<Callback<S>>>,
    state: S,
    server_ip: Option<String>,
}
\end{lstlisting}
ClientHandler is a struct that accepts one generic argument, named S. S needs to implement the interface State (which in turn requires an implementation of the interface Default). "ClientHandler" has three fields:
\begin{itemize}
    \item Callbacks - A hashmap used to map capabilities (stored as Strings), to user defined callback functions.
    \item State - Of type S, used to store the state of the program.
    \item Server\_ip - Of type option, stores either a string representation of the server's IP address and port, or None. It has the option type, due to there being multiple ways of giving the ClientHandler the server's IP address, however the client will not start if server\_ip is None when the "run" method is called.
\end{itemize}

Once the ClientHandler has been constructed, we use the builder pattern mentioned in subsection~\ref{sec:chapimpl:server:startup}, a very common Rust pattern. There are a few methods currently implemented on the ClientHandler, which we can call using this pattern. The most common one is the "add\_callback" function. We use this to give the ClientHandler a pointer (signified by the "Box" struct in Rust) to our function, along with the capability (defined in the config.toml file) it should be called for. If the user does not add a custom callback, the default callback is used instead, which looks like this (snippet from \textit{\textbf{client\_library/src/client.rs}}):

\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
let callback = self.callbacks.get(&update.capability);
match callback {
    Some(v) => v(&mut self.state, request),
    None => println!(
        "Received signal to {}", update.capability
    ),
}
\end{lstlisting}
In summary, this snippet gets the callback from the callbacks hashmap defined on the ClientHandler, if the callback is defined by the user we call it, otherwise \textit{"Received signal to Turn On"} (for the capability "Turn On") is printed.

The "Client Handler" has some other useful functions which the user can call. Some examples of these are:
\begin{itemize}
    \item Set\_state - Allows the user to set the state of the program to the non-default implementation. Can be useful if the state is determined programatically. This could allow the machine to change behavior at runtime. An example of this is having different behaviour depending on where the device is located.
    \item Set\_server\_ip - While the IP can simply be set in the config and read at runtime, it can instead of be passed using this function. This allows the user to programmatically determine the IP address, for example using network discovery to discover the IP address of the server, instead of using static IPs like in this example.
\end{itemize}

These methods can be useful, but are not required for using the library. Once all callbacks have been and other additional user parameters have been added, the run method is called. The run method accepts the configuration (obtained through the load\_config function) for the device as a paramter and returns a future, which must be awaited using the await keyword (view subsection~\ref{sec:chapimpl:server:threads}). This allows the ClientHandler to be used concurrently to any other tasks the client has to perform. \todo{add a smaller blurb about what the ClientHandler does internally}

\subsubsection{Callback Functions}
Finally, the callback functions, used in the "add\_callback" method on the ClientHandler are defined. The ClientHandler struct accepts callback functions, that accept two parameters and return void (defined as having no return value in rust). The first parameter must be a Struct that implements the interface State, which the "ClientHandler" uses to infer the type of State in the above example. The second parameter must be of type Request. This is a simple struct that is currently not in use, but will be used in the future for the frontend to pass specific parameters to the client. For example, a slider's value on the frontend could be passed within the Request parameter. As mentioned, this is not implemented yet.

The functions in this case are fairly simple. They use the GPIO pin stored within the ExampleState to turn on and off the LED connected to the GPIO pin, using the methods defined in the rppal library.

\subsection{Device Registration} \label{sec:chapimpl:devicelib:registration}
While device registration is described in detail within subsection~\ref{sec:chapimpl:server:registration}, how the library handles registration on the client side will be briefly touched upon within this section.

While the code for client registration section is significantly more simple than that of the server registration, it has again been translated to pseudo code for consistency. The real code snippet can be found within \textit{\textbf{client\_library/src/client\_registration.rs}}: 
\begin{lstlisting}[language=Python, style=boxed, showstringspaces=false]{}
def register_self(
    public_key,
    capabilites,
    device_name,
    server_ip
):
    client = RegistrationServiceClient::connect(server_ip)
    registration_request = 
        new RegistrationRequest(name, public_key, capabilities)

    response = client.register(registration_request)
    return new ServerConnection(
        response.client_id,
        response.public_key,
        response.certificate
    )
\end{lstlisting}
The RegistrationServiceClient is the counterpart to the RegistrationServiceServer used by the gRPC server and is imported from the generated code from the RegistrationService protobuf file. We use the client returned by the "connect" method on the RegistrationServiceClient, to call the RPC function "register" (view subsection~\ref{sec:chapdesign:server:protoBufs} for more information on how RPC functions are defined). This then returns the fields required for communication with the server. Finally, we return the ServerConnection struct which is a basic struct from the client library defined as:
\begin{lstlisting}[language=Rust, style=boxed, showstringspaces=false]{}
pub struct ServerConnection {
    pub uuid: String,
    pub server_pub_key: rsa::RsaPublicKey,
    pub security_certificate: String,
}
\end{lstlisting}
which stores information required for communication with the server. 
\section{Networking} \label{sec:chapimpl:networking}
\todo{write this}

\section{Security} \label{sec:chapimpl:security}
This section will briefly showcase implementations of the protocols described within subsection~\ref{sec:chapdesign:security}.

\subsection{Certificates} \label{sec:chapimpl:security:certificates}

\subsection{Signatures} \label{sec:chapimpl:security:signatures}

\section{Web \& CLI Frontend} \label{sec:chapimpl:frontend}
This section will describe how both the Web and Command Line Interface (CLI) frontends were implemented. It will also discuss specific struggles that were encountered when attempting to create these, and solutions or workarounds to these. 
\subsection{Command Line Interface Frontend} \label{sec:chapimpl:cli}
The first frontend that was implemented was the CLI frontend. It allows a user to control any IoT devices connected to the server from a simple command line enviornment. I was also very useful for testing purposes, as it allowed me to test that the system was working from a simple interface.
\subsubsection{Running}
Running the CLI frontend is fairly simple. After compiling the binary from Rust with the compiler in release mode, simply run the binary with the flag "\textit{--server-address}" (shorthand is -s), inputting the gRPC address of the server as the server-address argument. This is made easy as the server outputs the address the gRPC server is running on at startup. For example:
\begin{lstlisting}[language=Bash, style=boxed, showstringspaces=false]{}
$ ./frontend -s 192.168.0.1:2302
\end{lstlisting}
will run the frontend if the server's IP address is \textit{192.168.0.1:2302}.

\subsubsection{Using the Interface}
Using the interface is quite simple. At startup the user will be greated with two options:
\begin{lstlisting}[language=, style=boxed, showstringspaces=false]{}
Connecting...
Connection Successful
Welcome to Nik's Smart Home System
Your Device id is: 9404bec6-6a07-4374-bb34-f31e5809e348

What would you like to do?
1. Control a device
2. Quit
\end{lstlisting}
If they select \textit{Control a device} (by entering the number 1), the frontend will fetch any devices connected to the server.
\begin{lstlisting}[language=, style=boxed, showstringspaces=false]{}
Fetching available devices...
0: Pi
1: Quit

What device would you like to control?:
\end{lstlisting}
Currently there is only one device connected to the server, with the name "Pi". If we select to control the "Pi", we will be met with the screen:

\begin{lstlisting}[language=, style=boxed, showstringspaces=false]{}
Heres what you can do:
0: Turn Off
1: Turn On
2: Quit
\end{lstlisting}
Under the hood, the frontend is fetching any capabilities defined within the config.toml being used by the device we are attempting to control. For more information how this works viewsection~\ref{sec:chapimpl:devicelib}. If we select any of the capabilities, we will be met with the text:
\begin{lstlisting}[language=, style=boxed, showstringspaces=false]{}
Making request....
Operation was successful
\end{lstlisting}
If the request was unsuccessfully received, then an error message will be printed instead:
\begin{lstlisting}[language=, style=boxed, showstringspaces=false]{}
Making request....
There was an error:
status: Unavailable, message: "error trying to connect: 
tcp connect error: Connection refused (os error 111)", 
details: [], metadata: MetadataMap { headers: {} }
\end{lstlisting}
If the request was successful, then the next time the client polls the server, they will receive the event that selected and the callback function attached to that event will be called, in this case turning on or off an LED connected to the device. For more information on this view section~\ref{sec:chapimpl:devicelib}.

\subsubsection{Implementation}
This section will give a description of how the CLI frontend functions and some design decisions made throughout. 

The CLI frontend is relatively simple when compared to the rest of this system. All logic is contained in the file \textit{\textbf{backend/src/frontend/frontend.rs}}. It uses gRPC to communicate with the server, using the same gRPC server as the devices. In fact, any device could also act as a frontend and vice-versa. The frontend API is defined within \textit{\textbf{protos/frontend}}. For example, the defintion for frontend definition is defined in \textit{\textbf{protos/frontend/registrationService.proto}} and looks like this:

\pagebreak
\begin{lstlisting}[language=protobuf3, style=boxed, showstringspaces=false]{}
syntax = "proto3";
package frontend.registration;
import "frontendTypes.proto";

service FrontendRegistrationService {
    rpc Register(RegistrationRequest) 
        returns (RegistrationResponse);
    rpc GetConnectedDevices(ConnectedDevicesRequest)
        returns (ConnectedDevicesResponse);
};

message RegistrationRequest {
    string device_name = 1;
}

message RegistrationResponse {
    string client_id = 2;
}

message ConnectedDevicesRequest {
    string client_id = 1;
}

message ConnectedDevicesResponse {
    repeated Device devices = 1;
}

message Device {
    string device_name = 1;
    string device_uuid = 2;
    repeated frontend.types.DeviceCapabilityStatus 
        capabilities = 3;
}
\end{lstlisting}
The frontend gRPC API has two functions, "Register" and "GetConnectedDevices". The Register function is used to register the frontend with the server. The frontend will then assign it an identifier, with which it can make requests. The GetConnectedDevices function is used by the frontend when the user requests connected devices. The server will respond with the device name, it's ID and any capabilities the device has. The server only responds with capabilities that are currently available.

\subsection{Web Frontend} \label{sec:chapimpl:frontend:web}
\subsection{Using JSON for the Frontend API} \label{sec:chapimpl:frontend:json}

Write about here:
- Show Json service in Rust
- Why its bound on localhost
- Why protobuf compiler needs Serialize and Deserialize on these structs

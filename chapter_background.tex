\chapter{Literature Review} \label{cha:chapter2}
This section will provide an in-depth analysis of different concepts mentioned in the litartuare related to building an IoT-System, specifically a Smart Home. This includes different IoT architectures, important factors that make a successful IoT system and different types of API designs. 

\section{IoT System Architectures} \label{sec:chap2:architectures}
Kamienski et al. describe a simple three layer architecture of an IoT system in \cite{DesigningOpenIotSystem}. Within this architecture, the top layer is the "Input System", from which any data that will influence the decisions of the IoT system will come from. Included in this are sensors, but also user facing interfaces. The second layer, known as the "Process System", is where any algorithms are run and system behavioral decisions are made. The goal of this layer is to gain an "improved understanding of the system where the  data comes from" \cite{DesigningOpenIotSystem}. The bottom layer is the "Output System", which are where decisions made by the Process System will be enacted. This is often represented as the devices connected to the IoT system.

This three layer architecture is expanded upon by Bansal and Kumar within \cite{IotEcosystemSurvey}, where three more architectures are described which expand upon the ideas within the three layer architecture. They are however more specialized than the three layer architecture. The first of these is a "Middleware Based" architecture, which can take many forms, but is usually combined with another type of architecture, with a middleware layer. The different types are described in detail by Zhang et al. in \cite{MiddlewareIOTSurvey}. The second is known as a "Fog Based" architecture, where certain tasks, usually those with less processing requirements, are calculated on device to reduce latency. More computationally expensive tasks are however calculated on a server in the cloud \cite{IoTArchitectures}.

The most relevant architecture to this report is known as a "Service Based" architecture (SBA). The SBA is defined around the concept of the Service Oriented Architectural (SOA) style \cite{InteractingSoaBasedIot} of software design. SOA is defined by the Open Group Foundation as an "architectural style that supports service-orientation", where a service is a "logical representation of a repeatable business activity that has a specified outcome" \cite{SoaSourceBook}. Each service is a "black box" any device interacting with it. Other devices use interfaces and API endpoints to make requests to the service and receive a result. A SOA is composed of many different services. In SBA, services are used to offer device functionality using interfaces, often using web based concepts such as SOAP or REST APIs \cite{TrustManagementSoaIot}. This allows devices with different capabilities and purposes to interact with the same system, allowing for an IoT system that is more flexible. 
\todo{Add section about which one I chose: Service Based Architecture}


\section{The Smart Home System} \label{sec:chap2:smarthome}
Sethi and Sarangi \cite{IoTArchitectures} define six components that need to be present within a social IoT setting. A social IoT system is defined as a IoT system where devices form relationships with other devices. While our smart home system will not be a social IoT system, some of these concepts are still of interest. These are: 
\begin{enumerate}
    \item ID: the device within the system needs to have a way of identifying 
        it.
    \item Meta-data: the device should have information regarding its form and 
        purpose
    \item Security Controls: the system should have some way of distinguishing 
        between different users. It should also be able to distinguish what 
        types of devices it can connect to or can connect to it.
    \item Service Discovery: each device should be able to discover other 
        devices connected to the system and what services they offer.
\end{enumerate}

There are some specific constraints specific to Smart Homes. Reliability is a key concern, due to the lack of a trained professional being available to fix any issues that arise. This is contrast to more industrial IoT settings, where there might be someone to fix any issues that arise. Another concern is the security and privacy of the system. Due to smart homes inherently having access to sensitive data (due to their position in someone's home), one must ensure that the system is both ethically sound and secure. The issue of security is further discussed in Subsection~\ref{sec:chap2:security}.
\todo{further add to this section, just not sure what yet}

\section{APIs and Web Interfaces} \label{sec:chap2:API}
The book "Designing Web APIs" makes an important distinction about APIs that can often be forgotten by developers. "Although APIs are designed to work with other programs, theyâ€™re mostly intended to be understood and used by humans writing those other programs" \cite{DesigningWebApis} (Chapter 1). Due to this reality, one must remember to design APIs appropriately. To help the API designer in doing that, there are multiple pre-defined architectural standards that they can use. 

\subsection{Request Response}
"Request Response" APIs (RRA) expose their interface through a web server, to which clients can make requests. A client will request data and will receive a response from the server. Common formats for requests and responses include JavaScript Object Notation (JSON) and Extensible Markup Language (XML). \cite{DesigningWebApis}. 

One popular type of RRA is known as Representational State Transfer (REST). Two important properties of REST is that it is used in Client-Server scenarios and that every request is stateless \cite{ArchitecturalStylesAPIs}. This means that every API request from the client to the server, must contain all information required to complete that request, without the server storing any of that information. Instead, all state is stored on the client. While this constraint might seem strange, it makes any API implementing REST easily scalable, and potentially easier/faster to build. The downside being inherently increased network traffic, with less control application behavior. \cite{ArchitecturalStylesAPIs}.

Another popular implementation of a RRA is known as the Remote Procedure Call Architecture (RPC). The key difference between RPC and REST is that RPC is about making an action on the server. In REST the client supplies the server with the information required to take an action, whereas using RPC the client tells the server what action to take. RPC APIs can usually express more nuance in their requests and are generally stateful. While RPC usually uses JSON or XML for requests and responses, there are multiple implementations, such as Google's gRPC and Apache Thrift, which do not. These are usually serialized and therefore consume less network traffic than non-serialized formats such as the aforementioned JSON \cite{DesigningWebApis}. 

\subsection{Event Driven}
Event driven APIs go in a different direction than RRAs. Instead of the client continuously requesting information from the server, the client registers with the Server once, then whenever there is an update the server sends the client a message notifying it of an update. This completely resolves the need for polling, the client continuously requesting updates from the server, which is often present in RAA API designs \cite{DesigningWebApis}.

Web sockets are a type of Event Driven API that utilize a bidirectional TPC connection between server and client. Unlike the previously mentioned API styles, a connection on a web socket stays active until closed \cite{WebsocketStandard}. Due to the bidirectional TCP connections both client and server can send one another packets, even at the same time \cite{DesigningWebApis}. This is in contrast to REST and RPC protocols, where only the client can contact the server. This comes at the downside of scalability, as a server must maintain a connection with every device that is connected with the server. Additionally, there are also issues when a client is on an unstable connection, as web sockets expect a client to stay connected, with the client having to reinitiate the connection if it is dropped \cite{DesigningWebApis}.

The final type of API that deserves a short mention is the Web Hook. Web hooks work in an unconventional manner, where the initiator of an exchange gives a URL to their own API endpoint. This URL is then used by the receiver. Whenever a new event for the initiator occurs, the receiver will send information about the event to the URL \cite{DesigningWebApis}. While at face value this may seem like an obvious solution in an IOT based environment, where devices are often waiting for an event from the central server, it makes less sense when one realizes that every device connected to this webhook will need to host some sort of HTTP server, to receive the API requests. This makes it unsuitable, especially in environments where IOT devices are low powered, embedded systems devices. Web hooks are often used in server to server communication, as in such a scenario they are trivial to set up (as servers will most likely already be setup to receive API requests) \cite{DesigningWebApis}.
\todo{Add section about which one I chose: RPC, specifically gRPC}

\section{Security} \label{sec:chap2:security}
I need to see with the word count if I can write this section \todo{view note}

